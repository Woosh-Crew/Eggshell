using System;
using System.Collections.Generic;
using System.IO;
using Eggshell.IO;

namespace Eggshell.Resources
{
	/// <summary>
	/// A resource holds a reference and its state to an
	/// asset. It uses a stream for loading the asset.
	/// </summary>
	public sealed class Resource : IObject
	{
		public Library ClassInfo { get; }

		private Resource()
		{
			ClassInfo = Library.Register( this );
			Components = new( this );
		}

		internal Resource( Pathing path ) : this( path.Virtual().Normalise().Hash(), path.Name( false ), path.Extension(), () => path.Info<FileInfo>().OpenRead() )
		{
			Components.Create<Origin>().Path = path;
		}

		internal Resource( int hash, string name, string extension, Func<Stream> stream ) : this()
		{
			Name = name;
			Identifier = hash;
			Extension = extension;
			Stream = stream;
		}

		public override int GetHashCode()
		{
			return Identifier;
		}

		public override string ToString()
		{
			return $"loaded:[{IsLoaded}]id:[{Identifier}]";
		}

		// Identification

		/// <summary>
		/// The UI friendly name used to represent this resource.
		/// Used currently in debug modes to see what the resource is.
		/// </summary>
		public string Name { get; }

		/// <summary>
		/// The identifier that's used for this resource. Which can be
		/// used in the registry. This will get generated by a virtualized
		/// path that has been normalised. Hash = super fast and nice.
		/// </summary>
		public int Identifier { get; }

		/// <summary>
		/// The file extension for this resource. Used when setting up an
		/// asset so it uses the correct binder or what ever the asset
		/// needs to do based on the extension.
		/// </summary>
		public string Extension { get; }

		// State

		/// <summary>
		/// Can this asset still be loaded, without having any asset
		/// references to it? Useful for when loading assets such as
		/// UI that doesn't need to be reloaded everytime its used.
		/// </summary>
		public bool Persistant { get; private set; }

		/// <summary>
		/// Is this resource currently loaded in memory? (Just checks
		/// if the source doesn't equal null)
		/// </summary>
		public bool IsLoaded => Source != null;

		// References

		/// <summary>
		/// The source asset that is cached when the resource finishes
		/// loading. Usually used for duplicating instances of it.
		/// </summary>
		public IAsset Source { get; private set; }

		/// <summary>
		/// All instances of the source asset that has been cloned. You
		/// get one of these when you load an asset.
		/// </summary>
		public List<IAsset> Instances { get; private set; }

		/// <summary>
		/// The stream that will load the target asset. (Such as when
		/// you want to load an asset from a path, it'll just open a
		/// read only file stream) 
		/// </summary>
		public Func<Stream> Stream { get; }

		/// <summary>
		/// Additional data this resource has, that is used for dependency
		/// injection (Such as origin)
		/// </summary>
		public Components<Resource> Components { get; }

		// Management

		/// <summary>
		/// Grabs the loaded asset from memory or will open a stream
		/// and load the asset, then return an instance of the asset
		/// </summary>
		public T Load<T>( bool persistant = false ) where T : class, IAsset, new()
		{
			Persistant ^= persistant;

			// Invalid File
			Source ??= Create<T>();
			if ( Source == null )
			{
				Terminal.Log.Error( "Invalid type for Resource, not loading." );
				return null;
			}

			if ( !IsLoaded )
			{
				using var stopwatch = Terminal.Stopwatch( $"Loaded Resource [{Name}, {Identifier}]" );
				using var stream = Stream.Invoke();
				Source.Load( stream );
			}

			return Clone<T>();
		}

		/// <summary>
		/// Unloads this asset from memory, if it is not persistent.
		/// (Pass through true as an arg to forcefully unload it)
		/// </summary>
		public void Unload( bool forcefully )
		{
			if ( !IsLoaded )
			{
				// Nothing was loaded
				return;
			}

			foreach ( var instance in Instances )
			{
				if ( instance == Source )
				{
					continue;
				}

				instance.Delete();
			}

			Instances.Clear();

			if ( forcefully || !Persistant )
			{
				Terminal.Log.Info( $"Unloading Resource [{Name}, {Identifier}]" );

				Source.Unload();
				Source.Delete();

				Source = null;
			}
		}

		/// <summary>
		/// Deletes this resource. You shouldn't need to do this unless
		/// you know what you are doing. Can't be deleted if its loaded.
		/// </summary>
		public void Delete()
		{
			Assert.IsTrue( IsLoaded, "Can't delete a loaded resource" );
			Assets.Registered.Remove( this );
		}

		// Internal Logic

		private T Clone<T>() where T : class, IAsset, new()
		{
			var instance = Source.Clone();

			if ( instance == null || instance == Source )
			{
				return (T)Source;
			}

			Instances ??= new();
			Instances.Add( instance );
			instance.Resource = this;

			return (T)instance;
		}

		private T Create<T>() where T : class, IAsset, new()
		{
			Assert.IsTrue( Source != null );

			Source = new T();

			if ( !Source.Setup( Extension ) )
			{
				// Invalid File, don't load
				Source = null;
				return null;
			}

			Source.Resource = this;
			return Source as T;
		}
	}
}
