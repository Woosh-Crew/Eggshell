using System;
using System.IO;
using Eggshell.IO;

namespace Eggshell.Resources
{
    /// <summary>
    /// A resource holds a reference and its state to an
    /// asset. It uses a stream for loading the asset.
    /// </summary>
    public sealed class Resource : IObject
    {
        public Library ClassInfo { get; }

        private Resource()
        {
            ClassInfo = Library.Register(this);
            Components = new(this);
        }
        
        public Resource(int hash, string name, string extension, Func<Stream> stream) : this()
        {
            Name = name;
            Identifier = hash;
            Extension = extension;
            Stream = stream;
        }

        public Resource(Pathing path) : this(
            path.Absolute().Virtual().Normalise().Hash(),      // ID
            path.Name(false),                       // Resource Name
            path.Extension(),                       // Extension
            () => path.Info<FileInfo>().OpenRead()  // Stream
        )
        {
            Components.Create<Origin>().Path = path;
        }

        public override int GetHashCode()
        {
            return Identifier;
        }

        // Identification

        /// <summary>
        /// The UI friendly name used to represent this resource.
        /// Used currently in debug modes to see what the resource is.
        /// </summary>
        public string Name { get; }

        /// <summary>
        /// The identifier that's used for this resource. Which can be
        /// used in the registry. This will get generated by a virtualized
        /// path that has been normalised. Hash = super fast and nice.
        /// </summary>
        public int Identifier { get; }

        /// <summary>
        /// The file extension for this resource. Used when setting up an
        /// asset so it uses the correct binder or what ever the asset
        /// needs to do based on the extension.
        /// </summary>
        public string Extension { get; }

        // State

        /// <summary>
        /// Can this asset still be loaded, without having any asset
        /// references to it? Useful for when loading assets such as
        /// UI that doesn't need to be reloaded everytime its used.
        /// </summary>
        public bool Persistant { get; private set; }

        /// <summary>
        /// Is this resource currently loaded in memory? (Just checks
        /// if the source doesn't equal null)
        /// </summary>
        public bool IsLoaded => Asset != null;

        // References

        /// <summary>
        /// The source asset that is cached when the resource finishes
        /// loading. Usually used for duplicating instances of it.
        /// </summary>
        public IAsset Asset { get; private set; }

        /// <summary>
        /// The stream that will load the target asset. (Such as when
        /// you want to load an asset from a path, it'll just open a
        /// read only file stream) 
        /// </summary>
        public Func<Stream> Stream { get; }

        /// <summary>
        /// Additional data this resource has, that is used for dependency
        /// injection (Such as origin)
        /// </summary>
        public Components<Resource> Components { get; }

        // Management

        /// <summary>
        /// Grabs the loaded asset from memory or will open a stream
        /// and load the asset, then return an instance of the asset
        /// </summary>
        public T Load<T>(bool persistant = false) where T : class, IAsset, new()
        {
            Persistant ^= persistant;

            if (IsLoaded)
            {
                // Already loaded
                return (T)Asset;
            }

            var asset = Create<T>();
            if (asset == null)
            {
                // Invalid File
                Terminal.Log.Error("Invalid type for Resource, not loading.");
                return null;
            }

            using var stopwatch = Terminal.Stopwatch($"Loaded Resource [{Name}, {Identifier}]");
            using var stream = Stream.Invoke();
            asset.Load(stream);

            return (T)(Asset = asset);
        }

        /// <summary>
        /// Unloads this asset from memory, if it is not persistent.
        /// (Pass through true as an arg to forcefully unload it)
        /// </summary>
        public void Unload(bool forcefully = false)
        {
            if (!IsLoaded)
            {
                // Nothing was loaded
                return;
            }

            if (!forcefully && Persistant)
            {
                // Can't Unload
                return;
            }

            Terminal.Log.Info($"Unloading Resource [{Name}, {Identifier}]");

            Asset.Unload();
            Asset.Delete();

            Asset = null;
        }

        private T Create<T>(T value = null) where T : class, IAsset, new()
        {
            Assert.IsTrue(Asset != null);

            var asset = value;
            asset ??= new();

            if (!asset.Setup(Extension))
            {
                // Invalid File, don't load
                return null;
            }

            asset.Resource = this;
            return asset;
        }
    }
}
