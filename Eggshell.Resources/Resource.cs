using System;
using System.Collections.Generic;
using System.IO;

namespace Eggshell.Resources
{
    /// <summary>
    /// A resource holds a reference and its state to an
    /// asset. It uses a stream for loading the asset
    /// through a handle.
    /// </summary>
    public class Resource<T> : Resource where T : class, IAsset, new()
    {
        /// <summary>
        /// The handle is responsible for loading the asset and keeping
        /// track of its loading state. We use the handle for either Wait
        /// or Requesting.
        /// </summary>
        private Handle<T> Handle { get; }

        /// <summary>
        /// Can this asset still be loaded, without having any asset
        /// references to it? Useful for when loading assets such as
        /// UI that doesn't need to be reloaded everytime its used.
        /// </summary>
        public bool Persistant { get; protected set; }

        public Resource(int id, string binder, Func<Stream> stream) : base(id, binder)
        {
            Handle = new(stream);
        }

        // State Control
        // --------------------------------------------------------------------------------------- //

        /// <summary>
        /// Grabs the loaded asset from memory or will open a stream
        /// and load the asset, then return an instance of the asset
        /// </summary>
        public Handle<T> Load(bool persistant = false)
        {
            Persistant ^= persistant;
            Handle.Setup(Create);

            return Handle;
        }

        /// <summary>
        /// Unloads the asset from memory, this will happen automatically
        /// if nothing references the asset anymore.
        /// </summary>
        public override void Unload(Action callback, bool forcefully = false)
        {
            if (!forcefully && Persistant)
            {
                // Can't Unload
                return;
            }
        }

        private T Create()
        {
            var asset = new T();
            if (!asset.Setup(Binder))
            {
                return null;
            }

            asset.Resource = this;
            return asset;
        }
    }

    /// <summary>
    /// A resource holds a reference and its state to an
    /// asset. It uses a stream for loading the asset.
    /// </summary>
    public abstract class Resource
    {
        private Resource()
        {
            Components = new(this);
            Tags = new();
        }

        public Resource(int id, string binder) : this()
        {
            Identifier = id;
            Binder = binder;
        }

        // Identification
        // --------------------------------------------------------------------------------------- //

        /// <summary>
        /// The identifier that's used for this resource. Which can be
        /// used in the registry. This will get generated by a virtualized
        /// path that has been normalised. Hash = super fast and nice.
        /// </summary>
        public int Identifier { get; }

        /// <summary>
        /// The file extension for this resource. Used when setting up an
        /// asset so it uses the correct binder or what ever the asset
        /// needs to do based on the extension.
        /// </summary>
        public string Binder { get; }

        /// <summary>
        /// Additional data this resource has, that is used for dependency
        /// injection (Such as origin)
        /// </summary>
        public Components<Resource> Components { get; }

        /// <summary>
        /// A set of tags that this resource has. Incredibly useful for defining
        /// what the asset is. Example : Wood Tag, Gun Tag, etc.
        /// </summary>
        public HashSet<string> Tags { get; }

        // Logic
        // --------------------------------------------------------------------------------------- //
       
        /// <summary>
        /// Unloads the asset from memory, this will happen automatically
        /// if nothing references the asset anymore.
        /// </summary>
        public abstract void Unload(Action callback, bool forcefully = false);
    }
}
