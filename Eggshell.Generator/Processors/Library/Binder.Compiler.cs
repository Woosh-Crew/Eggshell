using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Eggshell.Generator
{
	public class BinderCompiler : Processor
	{
		private ImmutableHashSet<ITypeSymbol> Queued { get; set; }

		public override bool IsProcessable( SyntaxTree tree )
		{
			var binding = Compilation.GetTypeByMetadataName( "Eggshell.Reflection.IBinding" );

			Queued = tree.GetRoot()
				.DescendantNodesAndSelf()
				.OfType<ClassDeclarationSyntax>()
				.Select( x => Model.GetDeclaredSymbol( x ) )
				.OfType<ITypeSymbol>()
				.Where( x => x.AllInterfaces.Contains( binding ) && !x.BaseType.Name.StartsWith( "Attribute" ) )
				.ToImmutableHashSet();

			return Queued.Count > 0;
		}

		public override void OnProcess()
		{
			foreach ( var typeSymbol in Queued )
			{
				Add( Create( typeSymbol ), suffix : "Generated" );
			}
		}

		public override void OnFinish() { }

		// Binding Compiler
		// --------------------------------------------------------------------------------------- //

		private string OnProperties( ITypeSymbol typeSymbol )
		{
			var builder = new StringBuilder();

			foreach ( var symbol in typeSymbol.GetMembers().Where( e => Property.IsValid( e, typeSymbol ) && (e as IPropertySymbol)?.SetMethod.DeclaredAccessibility == Accessibility.Public ) )
			{
				builder.AppendLine( $@"public {Factory.OnType( (symbol as IPropertySymbol)?.Type )} {symbol.Name} {{ get; set; }}" );
			}

			return builder.ToString();
		}

		private string Create( ITypeSymbol typeSymbol )
		{
			return $@"// This was generated by Eggshell.
using System;
using Eggshell;
using Eggshell.Reflection;

namespace {typeSymbol.ContainingNamespace}
{{
	[AttributeUsage( AttributeTargets.Class )]
	public class {typeSymbol.Name}Attribute : Attribute, IBinding
	{{
		{OnProperties( typeSymbol )}

		public void OnAttached( Library item ) {{ }}
	}}
}}";
		}
	}
}
