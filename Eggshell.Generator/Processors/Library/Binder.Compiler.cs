using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Eggshell.Generator
{
    public class BinderCompiler : Processor
    {
        private ImmutableHashSet<INamedTypeSymbol> Queued { get; set; }

        public override bool IsProcessable(SyntaxTree tree)
        {
            Queued = tree.GetRoot()
                .DescendantNodesAndSelf()
                .OfType<ClassDeclarationSyntax>()
                .Select(x => ModelExtensions.GetDeclaredSymbol(Model, x))
                .OfType<INamedTypeSymbol>()
                .Where(x => x.GetAttributes().Any(e => e.AttributeClass.Name.StartsWith("Binding")))
                .ToImmutableHashSet();

            return Queued.Count > 0;
        }

        public override void OnProcess()
        {
            foreach ( var typeSymbol in Queued )
            {
                Add(Create(typeSymbol), suffix : "Generated");
            }
        }

        public override void OnFinish() { }

        // Binding Compiler
        // --------------------------------------------------------------------------------------- //

        public string Target { get; set; }

        private string OnProperties(INamespaceOrTypeSymbol typeSymbol)
        {
            var builder = new StringBuilder();

            foreach ( var symbol in typeSymbol.GetMembers().Where(e => !e.IsStatic && Property.IsValid(e, typeSymbol) && (e as IPropertySymbol)?.SetMethod.DeclaredAccessibility == Accessibility.Public) )
            {
                var appendable = $@"public {Factory.OnType((symbol as IPropertySymbol)?.Type)} {symbol.Name} {{ get; set; }}";

                foreach ( var attribute in symbol.GetAttributes().Where(e => e.AttributeClass!.Name.StartsWith("OverrideAttribute")) )
                {
                    appendable = attribute.ConstructorArguments.Length > 1
                        ? appendable.Replace(attribute.ConstructorArguments[0].Value!.ToString(), attribute.ConstructorArguments[1].Value!.ToString())
                        : attribute.ConstructorArguments[0].Value!.ToString();
                }

                builder.AppendLine(appendable);
            }

            return builder.ToString();
        }

        private string OnBody(INamedTypeSymbol symbol)
        {
            if (symbol.GetMembers("Attached").IsEmpty)
            {
                return $@"public {Target} Attached {{ get; set; }}";
            }

            return string.Empty;
        }

        private string OnConstructor(INamedTypeSymbol typeSymbol)
        {
            var builder = new StringBuilder();

            foreach ( var symbol in typeSymbol.Constructors.Where(e => !e.IsStatic && !e.IsAbstract && !e.IsImplicitlyDeclared) )
            {
                var constructor = new StringBuilder($"public {typeSymbol.Name}Attribute(");

                // Build up single constructor
                for (var i = 0; i < symbol.Parameters.Length; i++)
                {
                    var parameter = symbol.Parameters[i];
                    constructor.Append($"{Factory.OnType(parameter.Type)} {parameter.Name}");

                    // Apply default value
                    if (parameter.HasExplicitDefaultValue)
                    {
                        var arg = parameter.ExplicitDefaultValue;

                        // This is aids...
                        if (parameter.Type.Name.Equals("string", StringComparison.OrdinalIgnoreCase))
                        {
                            arg = $@"""{arg}""";
                        }

                        constructor.Append($" = {arg}");
                    }

                    if (i != symbol.Parameters.Length - 1)
                    {
                        constructor.Append(", ");
                    }
                }

                builder.AppendLine(constructor.Append(") { }").ToString());
            }

            return builder.ToString();
        }

        private string Create(INamedTypeSymbol typeSymbol)
        {
            var attribute = typeSymbol.GetAttributes().First(e => e.AttributeClass.Name.StartsWith("Binding")).NamedArguments.FirstOrDefault(e => e.Key == "Type");
            var target = attribute.Value.ToCSharpString().Replace("typeof(", "").TrimEnd(')');

            Target = target;

            return $@"// This was generated by Eggshell.
using System;
using Eggshell;
using Eggshell.Reflection;

namespace {typeSymbol.ContainingNamespace}
{{
	[AttributeUsage( AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property ), Binding]
	public class {typeSymbol.Name}Attribute : Attribute, {Target}.Binding
	{{
		public {Target} Attached {{ get; set; }}

		{OnConstructor(typeSymbol)}

		{OnProperties(typeSymbol)}
	}}

	partial class {typeSymbol.Name} : {Target}.Binding
	{{
		{OnBody(typeSymbol)}
	}}
}}";
        }
    }
}
