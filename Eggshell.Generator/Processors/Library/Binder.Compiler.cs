using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Eggshell.Generator
{
	public class BinderCompiler : Processor
	{
		private ImmutableHashSet<INamedTypeSymbol> Queued { get; set; }

		public override bool IsProcessable( SyntaxTree tree )
		{
			Queued = tree.GetRoot()
				.DescendantNodesAndSelf()
				.OfType<ClassDeclarationSyntax>()
				.Select( x => Model.GetDeclaredSymbol( x ) )
				.OfType<INamedTypeSymbol>()
				.Where( x => x.GetAttributes().Any( e => e.AttributeClass.Name.StartsWith( "Binding" ) ) )
				.ToImmutableHashSet();

			return Queued.Count > 0;
		}

		public override void OnProcess()
		{
			foreach ( var typeSymbol in Queued )
			{
				Add( Create( typeSymbol ), suffix : "Generated" );
			}
		}

		public override void OnFinish() { }

		// Binding Compiler
		// --------------------------------------------------------------------------------------- //

		private string OnProperties( INamespaceOrTypeSymbol typeSymbol )
		{
			var builder = new StringBuilder();

			foreach ( var symbol in typeSymbol.GetMembers().Where( e => Property.IsValid( e, typeSymbol ) && (e as IPropertySymbol)?.SetMethod.DeclaredAccessibility == Accessibility.Public ) )
			{
				var appendable = $@"public {Factory.OnType( (symbol as IPropertySymbol)?.Type )} {symbol.Name} {{ get; set; }}";

				foreach ( var attribute in symbol.GetAttributes().Where( e => e.AttributeClass!.Name.StartsWith( "OverrideAttribute" ) ) )
				{
					appendable = attribute.ConstructorArguments.Length > 1
						? appendable.Replace( attribute.ConstructorArguments[0].Value!.ToString(), attribute.ConstructorArguments[1].Value!.ToString() )
						: attribute.ConstructorArguments[0].Value!.ToString();
				}

				builder.AppendLine( appendable );
			}

			return builder.ToString();
		}

		private string OnBody( INamedTypeSymbol symbol )
		{
			if ( symbol.GetMembers( "OnAttached" ).IsEmpty )
			{
				return $@"public void OnAttached( Library item ) {{ }}";
			}

			return string.Empty;
		}	

		private string OnConstructor( INamedTypeSymbol typeSymbol )
		{
			var builder = new StringBuilder();

			foreach ( var symbol in typeSymbol.Constructors )
			{
				var constructor = new StringBuilder( $"public {typeSymbol.Name}Attribute(" );

				// Build up single constructor
				for ( var i = 0; i < symbol.Parameters.Length; i++ )
				{
					var parameter = symbol.Parameters[i];
					constructor.Append( $"{Factory.OnType( parameter.Type )} {parameter.Name}" );

					// Apply default value
					if ( parameter.HasExplicitDefaultValue )
					{
						var arg = parameter.ExplicitDefaultValue;

						// This is aids...
						if ( parameter.Type.Name.Equals( "string", StringComparison.OrdinalIgnoreCase ) )
						{
							arg = $@"""{arg}""";
						}

						constructor.Append( $" = {arg}" );
					}

					if ( i != symbol.Parameters.Length - 1 )
					{
						constructor.Append( ", " );
					}
				}

				builder.AppendLine( constructor.Append( ") { }" ).ToString() );
			}

			return builder.ToString();
		}

		private string Create( INamedTypeSymbol typeSymbol )
		{
			return $@"// This was generated by Eggshell.
using System;
using Eggshell;
using Eggshell.Reflection;

namespace {typeSymbol.ContainingNamespace}
{{
	[AttributeUsage( AttributeTargets.Class ), Binding]
	public class {typeSymbol.Name}Attribute : Attribute, IBinding
	{{
		{OnConstructor( typeSymbol )}

		{OnProperties( typeSymbol )}

		public void OnAttached( Library item ) {{ }}
	}}

	partial class {typeSymbol.Name} : IBinding
	{{
		{OnBody(typeSymbol)}
	}}
}}";
		}
	}
}
