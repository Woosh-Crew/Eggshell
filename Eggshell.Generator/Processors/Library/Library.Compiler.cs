using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Eggshell.Generator
{
	public class LibraryCompiler : Processor
	{
		private ImmutableHashSet<ITypeSymbol> Queued { get; set; }

		// Processor
		// --------------------------------------------------------------------------------------- //

		public override bool IsProcessable( SyntaxTree tree )
		{
			var libraryInterface = Compilation.GetTypeByMetadataName( "Eggshell.ILibrary" );

			Queued = tree.GetRoot()
				.DescendantNodesAndSelf()
				.OfType<ClassDeclarationSyntax>()
				.Select( x => Model.GetDeclaredSymbol( x ) )
				.OfType<ITypeSymbol>()
				.Where( x => x.AllInterfaces.Contains( libraryInterface ) || x.GetAttributes().Any( e => e.AttributeClass!.Name.StartsWith( "Library" ) ) )
				.ToImmutableHashSet();

			return Queued.Count > 0;
		}

		public override void OnProcess()
		{
			foreach ( var typeSymbol in Queued )
				Create( typeSymbol );
		}

		public override void OnFinish()
		{
			if ( Generated.Count == 0 )
				return;

			Add( Finalise(), $"{Compilation.AssemblyName}.Classroom" );
		}

		// Library Compiler
		// --------------------------------------------------------------------------------------- //

		private List<string> Generated { get; } = new();

		private StringBuilder Instances { get; } = new();
		private StringBuilder Names { get; } = new();

		private void Create( ITypeSymbol typeSymbol )
		{
			var name = Factory.OnType( typeSymbol );

			if ( Processed.Contains( name ) )
				return;

			Processed.Add( name );

			// Item has base type, cache it first.
			var hasBaseType = typeSymbol.BaseType != null && typeSymbol.BaseType.AllInterfaces.Any( e => e.Name.StartsWith( "ILibrary" ) );

			var baseTypeInAssembly = typeSymbol.BaseType?.ContainingAssembly.Equals( Context.Compilation.Assembly, SymbolEqualityComparer.Default ) ?? false;

			if ( hasBaseType && baseTypeInAssembly )
				Create( typeSymbol.BaseType );

			// Dont touch it, its so aids
			var baseTypeName = Factory.OnType( typeSymbol.BaseType );
			var baseTypeText = hasBaseType && baseTypeInAssembly
				? $"Instance_{baseTypeName.Replace( '.', '_' )}"
				: baseTypeInAssembly
					? "null"
					: typeSymbol.BaseType.AllInterfaces.Any( e => e.Name.StartsWith( "ILibrary" ) )
						? $"typeof({baseTypeName})"
						: "null	";

			Generated.Add( new Library( typeSymbol ).Compile( out var varName ) );

			Instances.AppendLine( $"var Instance_{varName} = new {varName}( {baseTypeText} );" );
			Names.AppendLine( $"Library.Database.Add( Instance_{varName} );" );
		}

		// Finish Compiling
		// --------------------------------------------------------------------------------------- //

		private string Finalise()
		{
			return $@"// This was generated by Eggshell.
using Eggshell;
using Eggshell.Reflection;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace Eggshell.Generated
{{
	[CompilerGenerated]
	public static class Classroom
	{{
		public static void Cache()
		{{
			{Instances}
			{Names}
		}}		

		{string.Join( "\n\t\t", Generated )}
	}}
}}";
		}
	}
}
